// #pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesGlobal.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/TilingAndBinningUtilities.hlsl"

/* ------------------------------ Inputs ------------------------------------ */

// 1x list for all entites (sorted by category, we concatenate lists of all views).
StructuredBuffer<float2> _wBoundsBuffer; // {w_min, w_max}

/* ------------------------------ Outputs ----------------------------------- */

// 1x list for all entites (sorted by category, we concatenate lists of all views).
// The size of the buffer can be computed as follows:
// Z_BIN_COUNT * BOUNDEDENTITYCATEGORY_COUNT * EYE_COUNT * (4 bytes per range).
// For example (1080p): 8192 * 5 * 1 * 4 = 160 KiB.
RWStructuredBuffer<uint> _zBinBuffer; // {last << 16 | first}

/* ------------------------------ Utilities --------------------------------- */

/* ------------------------------ Implementation ---------------------------- */

float2 ComputeZBinLinearDepthBounds(uint bin, float4 encodingParams)
{
    float2 bBounds = float2(bin, bin + 1);
    float2 zBounds = saturate(bBounds * rcp(Z_BIN_COUNT));

    float2 wBounds = float2(DecodeLogarithmicDepth(zBounds.x, encodingParams),
                            DecodeLogarithmicDepth(zBounds.y, encodingParams));

    // Reminder: Z-binning uses n=0.1 as the near plane.
    // In case the actual near plane is closer (or is oblique),
    // we must extend the first bin to include the lights
    // that are very close to the camera.
    // Note that this will not cause the lights behind the near plane
    // to be included, since they have invalid AABBs.
    wBounds.x = (bin == 0) ? 0 : wBounds.x;

    return wBounds; // TODO: add epsilon for numerical robustness?
}

#define THREADS_PER_GROUP (64)

#if IS_MULTIPLE(Z_BIN_COUNT, THREADS_PER_GROUP)
    #error "Z_BIN_COUNT must be an integer multiple of THREADS_PER_GROUP."
#endif

[numthreads(THREADS_PER_GROUP, 1, 1)]
void main(uint threadID : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    const uint t   = threadID;
    const uint g   = groupID.x;
    const uint cat = groupID.y;
    const uint eye = groupID.z;

    const uint bin = IndexFromCoordinate(uint2(t, g), THREADS_PER_GROUP);

    // Entities are sorted by category.
    const uint entityIndex = s_BoundedEntityOffsetPerCategory[cat];
    const uint entityCount = s_BoundedEntityCountPerCategory[cat];

    uint first = UINT16_MAX, last = 0;

    if (entityCount > 0) // Avoid wasted work
    {
        const float2 binBounds  = ComputeZBinLinearDepthBounds(bin, _ZBinBufferEncodingParams);
        const uint   inputStart = ComputeEntityBoundsBufferIndex(entityIndex, eye);

        // The algorithm is O(n * m) where 'n' is the entity count and 'm' is bin count.
        // Therefore, it will be slow if 'n' is large.
        // TODO: we should consider a sorting-based algorithm, which could be closer to O((n + m) * log(n)).
        // TODO: should Z-binning be two-pass as well (coarse bins, fine bins)? This would improve performance for large entity counts.
        // TODO: unroll.
        for (uint i = 0; i < entityCount; i++)
        {
            float2 entityBounds = _wBoundsBuffer[inputStart + i];

            // TODO: flatten.
            if (IntervalsOverlap(entityBounds, binBounds))
            {
                // We store intra-category indices.
                first = min(i, first);
                last  = max(i, last);
            }
        }
    }

    uint outputIndex = ComputeZBinBufferIndex(bin, cat, eye);
    uint outputRange = (last << 16) | first;

    _zBinBuffer[outputIndex] = outputRange;
}
